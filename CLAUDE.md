# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

**sitelog** is a Flutter construction-site event logging app. It tracks labor events and safety incidents per site, with offline-first local storage (Drift/SQLite) and cloud sync via Supabase. The app targets Android, iOS, macOS, Linux, Windows, and Web.

## Commands

```bash
# Run the app (debug)
flutter run

# Run on a specific device/emulator
flutter run -d <device-id>

# Run all tests
flutter test

# Run a single test file
flutter test test/features/daily_reports/usecases/add_site_event_test.dart

# Run tests with coverage
flutter test --coverage

# Regenerate build_runner output (json_serializable, injectable, drift, retrofit)
flutter pub run build_runner build --delete-conflicting-outputs

# Watch mode for code generation during development
flutter pub run build_runner watch --delete-conflicting-outputs

# Lint / analyze
flutter analyze

# Get dependencies
flutter pub get

# Build release APK (Android)
flutter build apk --release

# Build release app bundle (Android)
flutter build appbundle --release
```

## Architecture

Clean Architecture with feature-based module organization. Each feature lives under `lib/features/<feature>/` and is divided into three layers:

```
lib/features/<feature>/
├── domain/          # Pure business logic — no Flutter or package dependencies
│   ├── entities/    # Equatable value objects (the domain's source of truth)
│   ├── repositories/# Abstract interfaces only — defines contracts for data access
│   └── usecases/    # Single-responsibility business operations; orchestrate entities + repositories
├── data/            # Implements domain contracts with concrete tech (Drift, Retrofit, Supabase)
│   ├── datasources/ # Raw data access: local (Drift tables) and remote (Retrofit API clients)
│   ├── models/      # JSON-serializable DTOs that map to/from domain entities; .g.dart files are generated
│   └── repositories/# Concrete repository implementations — wire datasources, handle sync logic
└── presentation/    # Flutter UI only
    ├── bloc/        # BLoC + Events + States for this feature
    ├── pages/       # Screen-level widgets (routed to)
    └── widgets/     # Reusable UI components scoped to this feature
```

**Current feature**: `daily_reports` — the only feature implemented so far. Its domain layer (entities, repository interface, use cases) and data models are complete. The data datasources/repositories and the entire presentation layer are stubs awaiting implementation.

### Key Architectural Decisions

- **State management**: BLoC (`flutter_bloc`). Each feature's `presentation/bloc/` will contain the bloc, event, and state classes.
- **Dependency injection**: `get_it` + `injectable`. The root `lib/injection.dart` is the planned entry point; all repositories, datasources, and use cases will be registered there (with generated `injection.g.dart`).
- **Networking**: `dio` + `retrofit`. Retrofit API client interfaces will live in `data/datasources/` and have their implementation generated by `build_runner`.
- **Local database**: `drift` over SQLite (`sqlite3_flutter_libs`). Drift table definitions and generated DAO code will go in `data/datasources/`.
- **Cloud backend**: `supabase_flutter`. Supabase credentials/config will be loaded at app startup — keep those out of source control.
- **Serialization / code gen**: `json_serializable` for models, `injectable_generator` for DI, `retrofit_generator` for API clients, `drift_dev` for database. All four are driven by a single `build_runner` invocation. Generated files match the pattern `*.g.dart` or `*.drift.dart`.

### Domain Layer Details (`daily_reports`)

- **`SiteEvent`** is an abstract `Equatable` base class. Concrete types: `LaborEvent` (workerCount, description) and `SafetyIncident` (description, Severity enum).
- **`ReportRepository`** exposes: `getEventsForSite` (returns a `Stream` for live updates), `addSiteEvent`, `deleteSiteEvent`, and `syncEvents` (manual cloud push).
- **Use cases** are plain classes with a single `call()` method. `AddSiteEvent` performs validation (no future timestamps, workerCount > 0) before delegating to the repository.

### Data Layer Details (`daily_reports`)

- **Models** (`site_event_model.dart`) extend the domain entities directly and add `fromJson`/`toJson` via `json_serializable`. Each `toJson` stamps a `type` discriminator (`"labor"` or `"safety_incident"`) so the remote/local layer can distinguish subtypes.

## Test Layout

Tests mirror `lib/` under `test/`:

```
test/
├── widget_test.dart                          # Root smoke test
└── features/daily_reports/
    ├── domain/entities/site_event_test.dart  # Entity equality & summary formatting
    └── usecases/
        ├── add_site_event_test.dart          # Validation logic (mocktail mocks)
        └── get_site_event_test.dart          # Stream delegation
```

Tests use **mocktail** for mocking. The convention is: one `MockRepository` class per test file that implements the relevant abstract repository, and a `FakeSiteEvent` registered as a fallback value where needed.

## Notes on Incomplete Scaffolding

Several files/directories exist as placeholders and have no code yet:
- `lib/injection.dart` — DI registration (get_it + injectable)
- `lib/core/util/constants.dart` — app-wide constants
- `lib/core/errors/`, `lib/core/network/`, `lib/core/usecases/` — shared core abstractions
- `lib/features/daily_reports/data/datasources/` — Drift tables + Supabase/Retrofit clients
- `lib/features/daily_reports/data/repositories/` — concrete `ReportRepository` implementation
- `lib/features/daily_reports/presentation/` — BLoC, pages, widgets

When implementing any of these, follow the patterns already established in the domain and model layers.
